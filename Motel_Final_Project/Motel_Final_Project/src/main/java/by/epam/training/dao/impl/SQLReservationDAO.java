package by.epam.training.dao.impl;import by.epam.training.dao.*;import by.epam.training.connectionpool.ConnectionPoolException;import by.epam.training.connectionpool.impl.ConnectionPoolImpl;import by.epam.training.domain.Reservation;import by.epam.training.service.ServiceException;import com.mysql.jdbc.Connection;import org.apache.log4j.Logger;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Date;import java.util.concurrent.TimeUnit;/** * Class {@code DAOFactory} is the class, that implements methods to connect * to the information of reservations in the data base. * @author Mikhail Kerko */public class SQLReservationDAO implements ReservationDAO {    private static final SQLReservationDAO sqlReservationDAO = new SQLReservationDAO();    private final static Logger logger = Logger.getRootLogger();    private static final String RESERVATION_CHECK_SQL= "SELECT * FROM orders WHERE Start_date=? AND End_date=? AND Room_id=?";    private static final String CREATE_RESERVATION_SQL= "INSERT INTO orders (Start_date, End_date, User_id, Numb_of_guests, Room_id) VALUES(?, ?, ?, ?, ?)";    private static final String GET_RESERVATIONS_BY_ID_SQL = "SELECT * FROM orders WHERE User_id=?";    private static final String GET_ALL_RESERVATIONS_SQL = "SELECT * FROM orders WHERE User_id<>?";    private static final String DELETE_RESERVATION_SQL = "DELETE FROM orders WHERE Order_id=?";    private static final String APPROVE_RESERVATION_SQL = "UPDATE orders SET Is_approved='1' WHERE Order_id=?";    private static final String DEBIT_FUNDS_SQL = "UPDATE user_info SET Cash_account=? WHERE User_id=?";    private static final String GET_ROOM_PRICE_SQL = "SELECT * FROM room_info WHERE Room_id=?";    private static final String GET_LAST_RESERVATION_SQL = "SELECT * FROM orders ORDER BY Order_id DESC LIMIT 1";    private static final String DELETE_LAST_RESERVATION_SQL = "DELETE FROM orders ORDER BY Order_id DESC LIMIT 1";    public static SQLReservationDAO getInstance(){        return sqlReservationDAO;    }    /**     * <p>Checks if the reservation exists i the data base.</p>     * @param startDate is the date, when reservation starts.     * @param endDate is the date, when reservation ends.     * @param guestNumber is the number of the guests for this room.     * @param roomID is the number of the room which is to be reserved.     * @param userID is identifying number of the user, did this reservation.     * @return {@code true} if this reservation exists; {@code false} otherwise.     */    @Override    public boolean checkReservation(String startDate, String endDate, String userID, String guestNumber, String roomID) throws DAOException {        logger.info("====================CHECK RESERVATION=========================");        logger.info("You call check reservation.");        Connection connection = null;        boolean status = false;        PreparedStatement statement = null;        ResultSet resultSet;        try{            connection = ConnectionPoolImpl.getInstance().takeConnection();            logger.info("Connection is created.");            statement = connection.prepareStatement(RESERVATION_CHECK_SQL);            logger.info("Statement is OK.");            statement.setString(1, String.valueOf(startDate));            statement.setString(2, String.valueOf(endDate));            statement.setString(3, roomID);            resultSet = statement.executeQuery();            if( resultSet.next() ){                status = true;            }        } catch(SQLException | ConnectionPoolException e){            throw new DAOException(e);        } finally {            SQLHelper.finalMethod(connection, statement);        }        logger.info("=============================================");        return status;    }    /**     * <p>Gets ID of the existing reservation.</p>     * @param startDate is the date, when reservation starts.     * @param endDate is the date, when reservation ends.     * @param guestNUmber is the number of the guests for this room.     * @param roomID is the number of the room which is to be reserved.     * @param userID is identifying number of the user, did this reservation.     * @return {@code ID} of the reservation.     */    @Override    public Reservation getReservation(String startDate, String endDate, String userID, String guestNUmber, String roomID) throws DAOException {        logger.info("====================GET RESERVATION=========================");        logger.info("Call getReservation.");        Reservation reservation = new Reservation(getID(startDate, endDate, roomID),userID, guestNUmber, roomID, startDate, endDate, false);        logger.info("=============================================");        return reservation;    }    /**     * <p>Gets the price of the necessary room.</p>     * @param roomID is the number of the room which is to be reserved.     * @return {@code String} with the room price.     */    @Override    public String getRoomPrice(String roomID) throws DAOException{        logger.info("======================GET ROOM PRICE=======================");        logger.info("You call getRoomPrice.");        Connection connection = null;        PreparedStatement statement = null;        ResultSet resultSet;        String toDebit = null;        try{            connection = ConnectionPoolImpl.getInstance().takeConnection();            logger.info("Connection is created.");            statement = connection.prepareStatement(GET_ROOM_PRICE_SQL);            logger.info("Statement is OK.");            statement.setString(1, roomID);            resultSet = statement.executeQuery();            if( resultSet.next()){                toDebit = resultSet.getString("Day_price");            }        } catch(SQLException e){            throw new DAOException(e);        } catch (ConnectionPoolException e) {            logger.warn(e.getMessage());            throw new DAOException(e);        } finally {            SQLHelper.finalMethod(connection, statement);        }        logger.info("=============================================");        return toDebit;    }    /**     * <p>Checks if the reservation exists i the data base.</p>     * @return {@code true} if operation ended with no errors; {@code false} otherwise.     */    @Override    public boolean deleteLastReservation() throws DAOException{        logger.info("====================DELETE LAST RESERVATION=========================");        logger.info("You call deleteLastReservation.");        Connection connection = null;        PreparedStatement statement = null;        int countRows;        try{            connection = ConnectionPoolImpl.getInstance().takeConnection();            logger.info("Connection is created.");            statement = connection.prepareStatement(DELETE_LAST_RESERVATION_SQL);            logger.info("Statement is OK.");            countRows = statement.executeUpdate();        } catch(SQLException | ConnectionPoolException e){            throw new DAOException(e);        } finally{            SQLHelper.finalMethod(connection, statement);        }        if( countRows > 0){            logger.info("Reservation deleted.");            logger.info("=============================================");            return true;        } else {            logger.info("Reservation is not deleted.");            logger.info("=============================================");            return false;        }    }    /**     * <p>Approves last reservation in the data base.</p>     */    @Override    public void approveLastReservation() throws DAOException {        logger.info("======================APPROVE LAST RESERVATION=======================");        logger.info("You call approveLastReservation.");        Reservation reservation = getLastReservation();        approveReservation(String.valueOf(reservation.getOrderID()));        logger.info("=============================================");    }    /**     * <p>Gets last reservation from the data base.</p>     * @return {@code Reservation} is last reservation in the table.     */    @Override    public Reservation getLastReservation() throws DAOException{        logger.info("======================GET LAST RESERVATION=======================");        logger.info("You call getLastReservation.");        Connection connection = null;        PreparedStatement statement = null;        ResultSet resultSet;        Reservation reservation = null;        try{            connection = ConnectionPoolImpl.getInstance().takeConnection();            logger.info("Connection is created.");            statement = connection.prepareStatement(GET_LAST_RESERVATION_SQL);            logger.info("Statement is OK.");            resultSet = statement.executeQuery();            if( resultSet.next()){                reservation = new Reservation(                        getID(resultSet.getString("Start_date"), resultSet.getString("End_date"),                                resultSet.getString("Room_id")), resultSet.getString("User_id"),                        resultSet.getString("Numb_of_guests"), resultSet.getString("Room_id"),                        resultSet.getString("Start_date"), resultSet.getString("End_date"), resultSet.getBoolean("Is_approved"));            }        } catch(SQLException e){            throw new DAOException(e);        } catch (ConnectionPoolException e) {            logger.fatal(e.getMessage());            throw new DAOException(e);        } finally {            SQLHelper.finalMethod(connection, statement);        }        logger.info("=============================================");        return reservation;    }    /**     * <p>Creates new reservation in the data base.</p>     * @param startDate is the date, when reservation starts.     * @param endDate is the date, when reservation ends.     * @param guestNUmber is the number of the guests for this room.     * @param roomID is the number of the room which is to be reserved.     * @param userID is identifying number of the user, did this reservation.     * @return {@code true} if reservation created successfully; {@code false} otherwise.     */    @Override    public boolean createReservation(String startDate, String endDate, String userID, String guestNUmber, String roomID) throws DAOException, ServiceException {        logger.info("====================CREATE RESERVATION=========================");        logger.info("You call createReservation.");        Connection connection = null;        PreparedStatement statement = null;        int countRows;        long daysToLive;        String toDebit;        try{            connection = ConnectionPoolImpl.getInstance().takeConnection();            logger.info("Connection is created.");            statement = connection.prepareStatement(CREATE_RESERVATION_SQL);            logger.info("Statement is OK.");            statement.setString(1, String.valueOf(startDate));            statement.setString(2, String.valueOf(endDate));            statement.setString(3, userID);            statement.setString(4, guestNUmber);            statement.setString(5, roomID);            countRows = statement.executeUpdate();            SimpleDateFormat myFormat = new SimpleDateFormat("yyyy-MM-dd");            toDebit = getRoomPrice(roomID);            try {                Date date1 = myFormat.parse(startDate);                Date date2 = myFormat.parse(endDate);                long diff = date2.getTime() - date1.getTime();                logger.info ("Days: " + TimeUnit.DAYS.convert(diff, TimeUnit.MILLISECONDS));                daysToLive = TimeUnit.DAYS.convert(diff, TimeUnit.MILLISECONDS);                boolean debited = debitAccount(userID, toDebit, daysToLive);                logger.info("Debited = " + debited);            } catch (ParseException e) {                e.printStackTrace();            }        } catch(SQLException | ConnectionPoolException e){            throw new DAOException(e);        } finally {            SQLHelper.finalMethod(connection, statement);        }        if( countRows > 0){            logger.info("Reservation is registered.");            logger.info("=============================================");            return true;        } else {            logger.info("Reservation is not registered.");            logger.info("=============================================");            return false;        }    }    /**     * <p>Gets ID of the reservation, using nex parameters.</p>     * @param startDate is the date, when reservation starts.     * @param endDate is the date, when reservation ends.     * @param roomID is the number of the room which is to be reserved.     * @return {@code true} if reservationID found successfully; {@code false} otherwise.     */    @Override    public Long getID(String startDate, String endDate, String roomID) throws DAOException {        logger.info("======================GET ID=======================");        logger.info("You call getID.");        Connection connection = null;        PreparedStatement statement = null;        ResultSet resultSet;        Long id = null;        try{            connection = ConnectionPoolImpl.getInstance().takeConnection();            logger.info("Connection is created.");            statement = connection.prepareStatement(RESERVATION_CHECK_SQL);            logger.info("Statement is OK.");            statement.setString(1, String.valueOf(startDate));            statement.setString(2, String.valueOf(endDate));            statement.setString(3, roomID);            resultSet = statement.executeQuery();            if( resultSet.next()){                id = resultSet.getLong("Order_id");            }        } catch(SQLException e){            throw new DAOException(e);        } catch (ConnectionPoolException e) {            logger.warn(e.getMessage());            throw new DAOException(e);        } finally {            SQLHelper.finalMethod(connection, statement);        }        logger.info("=============================================");        return id;    }    /**     * <p>Gets list of reservations of the current user.</p>     * @param userID is identifying number of the user, did this reservation.     * @return {@code ArrayList} is a list of reservations of the user.     */    @Override    public ArrayList<Reservation> getReservationByID(String userID) throws DAOException {        logger.info("====================GET RESERVATIONS BY USER ID=========================");        logger.info("You call get reservation by user id.");        ArrayList<Reservation> reservations = new ArrayList<>();        Connection connection = null;        PreparedStatement statement = null;        ResultSet resultSet;        try{            connection = ConnectionPoolImpl.getInstance().takeConnection();            logger.info("Connection is created.");            statement = connection.prepareStatement(GET_RESERVATIONS_BY_ID_SQL);            statement.setString(1, String.valueOf(userID));            logger.info("Statement is OK.");            resultSet = statement.executeQuery();            while (resultSet.next()) {                Reservation reservation = new Reservation(                        getID(resultSet.getString("Start_date"), resultSet.getString("End_date"),                                resultSet.getString("Room_id")), resultSet.getString("User_id"),                        resultSet.getString("Numb_of_guests"), resultSet.getString("Room_id"),                        resultSet.getString("Start_date"), resultSet.getString("End_date"), resultSet.getBoolean("Is_approved"));                reservations.add(reservation);            }        } catch(SQLException | ConnectionPoolException e){            throw new DAOException(e);        } finally{            SQLHelper.finalMethod(connection, statement);        }        logger.info("=============================================");        return reservations;    }    /**     * <p>Gets all reservations, except reservations of the user.</p>     * @param userID is identifying number of the user, whose reservation we mustn't take.     * @return {@code ArrayList} is a list of reservations of the !user.     */    @Override    public ArrayList<Reservation> getAllReservations(String userID) throws DAOException {        logger.info("====================GET ALL RESERVATION=========================");        logger.info("You call get all reservation.");        ArrayList<Reservation> reservations = new ArrayList<>();        Connection connection = null;        PreparedStatement statement = null;        ResultSet resultSet;        try{            connection = ConnectionPoolImpl.getInstance().takeConnection();            logger.info("Connection is created.");            statement = connection.prepareStatement(GET_ALL_RESERVATIONS_SQL);            statement.setString(1, String.valueOf(userID));            logger.info("Statement is OK.");            resultSet = statement.executeQuery();            while (resultSet.next()) {                Reservation reservation = new Reservation(                        getID(resultSet.getString("Start_date"), resultSet.getString("End_date"),                                resultSet.getString("Room_id")), resultSet.getString("User_id"),                        resultSet.getString("Numb_of_guests"), resultSet.getString("Room_id"),                        resultSet.getString("Start_date"), resultSet.getString("End_date"), resultSet.getBoolean("Is_approved"));                reservations.add(reservation);            }        } catch(SQLException | ConnectionPoolException e){            throw new DAOException(e);        } finally{            SQLHelper.finalMethod(connection, statement);        }        logger.info("=============================================");        return reservations;    }    /**     * <p>Deletes reservation, using its ID.</p>     * @param orderID is the ID of the order to be deleted from the data base.     * @return {@code true} if reservationID deleted successfully; {@code false} otherwise.     */    @Override    public boolean deleteReservation(String orderID) throws DAOException {        logger.info("====================DELETE RESERVATION=========================");        logger.info("You call deleteReservation.");        Connection connection = null;        PreparedStatement statement = null;        int countRows;        try{            connection = ConnectionPoolImpl.getInstance().takeConnection();            logger.info("Connection is created.");            //create user            statement = connection.prepareStatement(DELETE_RESERVATION_SQL);            logger.info("Statement is OK.");            statement.setString(1, String.valueOf(orderID));            countRows = statement.executeUpdate();        } catch(SQLException | ConnectionPoolException e){            throw new DAOException(e);        } finally{            SQLHelper.finalMethod(connection, statement);        }        if( countRows > 0){            logger.info("Reservation deleted.");            logger.info("=============================================");            return true;        } else {            logger.info("Reservation is not deleted.");            logger.info("=============================================");            return false;        }    }    /**     * <p>Approves reservation, using its ID.</p>     * @param orderID is the id of the reservation to be deleted.     * @return {@code true} if reservationID approved successfully; {@code false} otherwise.     */    @Override    public boolean approveReservation(String orderID) throws DAOException {        logger.info("====================APPROVE RESERVATION=========================");        logger.info("You call approveReservation.");        Connection connection = null;        PreparedStatement statement = null;        int countRows;        try{            connection = ConnectionPoolImpl.getInstance().takeConnection();            logger.info("Connection is created.");            statement = connection.prepareStatement(APPROVE_RESERVATION_SQL);            logger.info("Statement is OK.");            statement.setString(1, String.valueOf(orderID));            countRows = statement.executeUpdate();        } catch(SQLException | ConnectionPoolException e){            throw new DAOException(e);        } finally {            SQLHelper.finalMethod(connection, statement);        }        if( countRows > 0){            logger.info("Reservation approved.");            logger.info("=============================================");            return true;        } else {            logger.info("Reservation is not approved.");            logger.info("=============================================");            return false;        }    }    /**     * <p>Debits cash from the account of the current user for the reservation.</p>     * @param userID is ID of the user, the reserved a room.     * @param toDebit is day price of the room user reserved.     * @param daysToLive is the number of the days, user planned to live in.     * @return {@code true} if the cash was debited successfully; {@code false} otherwise.     */    @Override    public boolean debitAccount(String userID, String toDebit, Long daysToLive) throws DAOException, ServiceException {        logger.info("====================DEBIT FUNDS=========================");        logger.info("You call debitAccount.");        Connection connection = null;        PreparedStatement statement = null;        int countRows;        Long willBeOnAccount;        DAOFactory daoFactory = DAOFactory.getDAOFactory();        UserDAO userDAO = daoFactory.getUserDAO();        if (Long.parseLong(userDAO.getCashAccount(userID)) - Long.parseLong(toDebit) * daysToLive < 0){            throw new ServiceException("You don't have enough money for this reservation");        }        try{            willBeOnAccount = Long.parseLong(userDAO.getCashAccount(userID)) - Long.parseLong(toDebit) * daysToLive;            connection = ConnectionPoolImpl.getInstance().takeConnection();            logger.info("Connection is created.");            statement = connection.prepareStatement(DEBIT_FUNDS_SQL);            logger.info("Statement is OK.");            statement.setString(1, String.valueOf(willBeOnAccount));            statement.setString(2, String.valueOf(userID));            countRows = statement.executeUpdate();        } catch(SQLException | ConnectionPoolException e){            throw new DAOException(e);        } finally{            SQLHelper.finalMethod(connection, statement);        }        if( countRows > 0){            logger.info("Money debited successfully.");            logger.info("=============================================");            return true;        } else {            logger.info("Money hasn't been debited.");            logger.info("=============================================");            return false;        }    }}